\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts}
\usepackage{gensymb}


\title{15-411: L6 Written Report}
\author{Manganese}
\date{December 14, 2015}

\begin{document}

\maketitle

\section{Introduction}

Our chosen L6 project was "C0 and Beyond", or C1. We extended the compiler from L4 in several ways. First, we implemented a compiler for the L5 language by implementing chars and strings as they are implemented in C0. Second, we implemented function pointers. Finally, as "something extra" we wrote new extensions to our compiler that allowed type inference, allowing type declarations to be foregone in assignments and function declarations/definitions, but not struct field declarations.

For our end result, we have a working compiler for L5 and function pointers, and some but not all aspects of L6 (type inference).
\section{Language Extensions}

Since type inference will cause some tests to typecheck that previously would have thrown an error, it is disabled by default, and can be enabled with the compilation flag --typeInference (i.e. ./top.native --typeInference $<$filename$>$).\\

\subsection{Strings and characters}
String constants and characters are now included in the $exp$ type from the L4 grammar. String constants are defined as the following regexp: (``) + (any character that isn't double quotes $\cup \  \backslash")^*$ +("). Disallowing double quotes in the string body is necessary, or else the lexer may take the longest lex and intepret ``hello"; ``bye"; as a single string.

Characters are defined as any OCaml character, plus several that don't appear in OCaml apparently, just as `$\backslash$ f'.

The semantics for strings and characters are just as defined in the handout: characters can be compared by their ascii values with $<. >, ==$, etc, strings cannot be compared but are treated as a small type.

\subsection{Function pointers}
The addition of function pointers to the L5 grammar was straightforward. A new type of gdecl (global declaration) was added with the form \begin{align*}
\textbf{typedef} \ \textrm{fdecl}
\end{align*}
The unary address-of operator $\&$ was also added, along with the new expression for a function pointer call.

The main interesting thing about the semantics for function pointers is the requirement that comparison is done nominally, as it tested by our test ``test18.l6".

\subsection{Basic type inference}
The addition of type inference to the L6 grammar was also straightforward. The main differences are that fdecls and fdefns not longer must begin with a type. So fdecls can also be of the form
\begin{align*}
\textbf{ident} \ \textrm{param-list};
\end{align*}
and fdefns can be also be of the form
\begin{align*}
\textbf{ident} \ \textrm{param-list} \ \textrm{block}
\end{align*}
Similarly, params no longer must begin a type. So params can also simply be an \textbf{ident}.

The semantics also required significant changes. On the more basic side, variables no longer must be declared before they are defined (although they must still be initialized). So something like\\
\\
main () \{\\
 x = 0;\\
 return x;\}\\
 \\
is ok now; the type of main is inferred to be int, and the type of x is inferred to be int. We also still only allow a variable to have single type in a given scope, so\\
\\
main () \{\\
 x= true;\\
 x = 0;\\
 return x;\}\\
 \\
is disallowed. 

Note that type annotations are still allowed of course. We also made \textbf{alpha} a keyword, and included a new type \textbf{alpha}$<n>$, where $n$ is any positive integer (so \textbf{alpha1}, \textbf{alpha2}, etc). The alpha type simply implies no type information: it is equivalent to leaving off the annotation. So ``alpha x = 0;" is equivalent to ``x = 0", except that the former still counts as a declaration, and redeclaring variables is still disallowed. So\\
\\
alpha1 x = 0;\\
int x = 0;\\
\\
would not typecheck.

There were other changes as well. We can infer the types of variables if they are used in expressions that only take certain types. For example, in the code below,
\\
f(x) { \\
  y = x + 1; \\
  return y; \\
} \\
\\
when we first parse f, we know neither its type nor the type of x. However, in the statement ``y = x + 1", we see that x must in fact be an integer. We propagate this information upwards, so the typechecked function definition becomes
\\
int f(int x) { \\
  int y = x + 1; \\
  return y; \\
} \\
\\
Our typechecker does this for all similar expressions that ``force" alpha expressions to have a type.

\subsection{Partial type annotations}
Also inspired by functional programming, we support ``partial type annotations". We define a partial type annotation to be an annotation which provides more information than just \textbf{alpha}, but does not fully specify the type. An example would be something like this:\\
\\
alpha1[] a = alloc$\_$array(int[], 5);\\
\}\\
\\
The type annotation on a means that a is ``some type of array". The type of the right-hand-side is int[][], which is indeed a type of array, so this typechecks. On the other hand, the following would not typecheck:\\
\\
alpha1[] a = 0;\\
\\
Since 0 is an int, which is not any type of array.

One subtlety of the alpha type is that it does not specify a size, so example 1 is disallowed. Example 2 is allowed however, since the size of alpha1[] is known.\\
\\
(example 1) alpha1[] a = alloc$\_$array(alpha1, 3);\\
(example 2) alpha1[][] a = alloc$\_$array(alpha1[], 3);\\
\\

\subsection{Polymorphism}
In order to make type inference more interesting, we decided to support some amount of polymorphism, specifically allowing polymorphic functions. For example, the function\\
\\
f(x) \{ return x; \}\\
\\
has type alpha1 $\to$ alpha1. Thus it can be called with any type as argument, so the following typechecks:\\
\\
main () \{\\
p = alloc(int);\\
return f(*p) + *f(p);\\
\}\\
\\
We also decided to completely ignore type inference for structs, because for something like ``struct s1 \{x;\}", since the size of x is needed at compile time. Even if you require type annotations on fields, we were not sure how to deal with the following:\\
\\
struct s1 \{int x; int y;\}\\
struct s2 \{int y;\}\\
f(s) \{return s$\to$y;\}\\
\\
Since it is now impossible to compute the field offset of y at compile time. There are even more issues with structs beyond these, but these were enough to deter us from even attempting to handle structs.

\section{Compilation}
\subsection{Strings and characters}
For strings and characters, we had to add new type-expressions to our intermediate languages and ASTs: a CharExpr type and a StringExpr type. This was straightforward, as we had already gone through the process of adding BoolExpr and PtrExpr types.

Using the regexp described previously, we convert string constants in the input file into a character list immediately during lexing. The regexp with which we defined string constants pretty much handled all of the challenges of strings, so parsing was straightforward.

At runtime, we represent string constants as a dynamically allocated array of characters. So s = "abc" becomes\\
\\
s = alloc$\_$array(char, 3);\\
s[0] = 'a';\\
s[1] = 'b';\\
s[2] = 'c';\\
\\
We realize that this is more costly than representing strings are text in the compiled binary as suggested in the handout, but this way we were able to reduce strings to a problem we had already solved, and we wanted more time to play around with type inference. As a result, we had no StringExpr in our intermediate languages; only in our ASTs.

After typechecking, characters are treated identically to integers except with regards to size.

\subsection{Function pointers}
We felt that typechecking was the most difficult part, because after typechecking we were able to represent function pointer calls very similarly to normal function calls. One tricky bug was that in liveness, the temp holding the function pointer cannot be allocated one of the argument registers being used for that call, but otherwise post-typechecking compilation of function pointers was relatively straightforward.\\ 

In typechecking, we check to make sure dereferenced function pointers first are declared, receive the correct number and types of parameters, and cannot be compared with other function pointers unless they are of the exact same type. The "address-of" operator can only precede the name of an existing function.
\subsection{Type inference}
BILLY EXPLAIN EVERYTHING ABOUT HOW WE IMPLEMENT TYPE INFERENCE

\section{Examples}

\section{Analysis}


\end{document}



